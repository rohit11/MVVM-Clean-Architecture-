name: Lock Environment (Project Board)

on:
  workflow_dispatch:
    inputs:
      env_name:
        description: "Environment row title in the Project (e.g., env-01, env-12)"
        required: true
        type: string
      ttl_hours:
        description: "How many hours to lock this env"
        required: true
        default: "8"
        type: string
      purpose:
        description: "Why you need this env (ticket/PR/testing)"
        required: true
        type: string

# Keep minimal permissions; we will use PROJECTS_TOKEN for GraphQL
permissions:
  contents: read

jobs:
  lock:
    runs-on: ubuntu-latest
    steps:
      - name: Lock env row in Project (Status/Owner/Purpose/Expires At)
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECTS_TOKEN }}
          script: |
            const envName = core.getInput('env_name').trim();
            const ttlHoursRaw = core.getInput('ttl_hours').trim();
            const purpose = core.getInput('purpose').trim();

            const ttlHours = Number(ttlHoursRaw);
            if (!Number.isFinite(ttlHours) || ttlHours <= 0) {
              throw new Error(`ttl_hours must be a positive number. Got: "${ttlHoursRaw}"`);
            }

            const expiresAt = new Date(Date.now() + ttlHours * 60 * 60 * 1000).toISOString();

            // IDs stored as repo variables
            const projectId = process.env.PROJECT_ID;
            const statusFieldId = process.env.STATUS_FIELD_ID;
            const inUseOptionId = process.env.STATUS_INUSE_OPTION_ID;
            const ownerFieldId = process.env.OWNER_FIELD_ID;
            const purposeFieldId = process.env.PURPOSE_FIELD_ID;
            const expiresFieldId = process.env.EXPIRES_FIELD_ID;

            for (const [k,v] of Object.entries({
              PROJECT_ID: projectId,
              STATUS_FIELD_ID: statusFieldId,
              STATUS_INUSE_OPTION_ID: inUseOptionId,
              OWNER_FIELD_ID: ownerFieldId,
              PURPOSE_FIELD_ID: purposeFieldId,
              EXPIRES_FIELD_ID: expiresFieldId
            })) {
              if (!v) throw new Error(`Missing repo variable: ${k}`);
            }

            // Find itemId by title (Pattern 1)
            const findItemResp = await github.graphql(`
              query($projectId: ID!) {
                node(id: $projectId) {
                  ... on ProjectV2 {
                    items(first: 100) {
                      nodes {
                        id
                        content {
                          __typename
                          ... on DraftIssue { title }
                          ... on Issue { title }
                        }
                      }
                    }
                  }
                }
              }
            `, { projectId });

            const nodes = findItemResp?.node?.items?.nodes ?? [];
            const norm = (s) => (s || "").trim().toLowerCase();
            const item = nodes.find(n => norm(n?.content?.title) === norm(envName));

            if (!item) {
              const titles = nodes.map(n => n?.content?.title).filter(Boolean);
              throw new Error(`Row "${envName}" not found. Titles: ${titles.join(", ")}`);
            }

            const itemId = item.id;
            const owner = context.actor; // <-- who ran the workflow

            async function updateSingleSelect(fieldId, optionId) {
              await github.graphql(`
                mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                  updateProjectV2ItemFieldValue(
                    input: { projectId: $projectId, itemId: $itemId, fieldId: $fieldId, value: { singleSelectOptionId: $optionId } }
                  ) { projectV2Item { id } }
                }
              `, { projectId, itemId, fieldId, optionId });
            }

            async function updateText(fieldId, text) {
              await github.graphql(`
                mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $text: String!) {
                  updateProjectV2ItemFieldValue(
                    input: { projectId: $projectId, itemId: $itemId, fieldId: $fieldId, value: { text: $text } }
                  ) { projectV2Item { id } }
                }
              `, { projectId, itemId, fieldId, text });
            }

            async function updateDate(fieldId, dateIso) {
              await github.graphql(`
                mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $date: Date!) {
                  updateProjectV2ItemFieldValue(
                    input: { projectId: $projectId, itemId: $itemId, fieldId: $fieldId, value: { date: $date } }
                  ) { projectV2Item { id } }
                }
              `, { projectId, itemId, fieldId, date: dateIso });
            }

            await updateSingleSelect(statusFieldId, inUseOptionId);
            await updateText(ownerFieldId, owner);
            await updateText(purposeFieldId, purpose);
            await updateDate(expiresFieldId, expiresAt);

            core.notice(`Locked ${envName} by ${owner} for ${ttlHours}h. Expires: ${expiresAt}`);
        env:
          PROJECT_ID: ${{ vars.PROJECT_ID }}
          STATUS_FIELD_ID: ${{ vars.STATUS_FIELD_ID }}
          STATUS_INUSE_OPTION_ID: ${{ vars.STATUS_INUSE_OPTION_ID }}
          OWNER_FIELD_ID: ${{ vars.OWNER_FIELD_ID }}
          PURPOSE_FIELD_ID: ${{ vars.PURPOSE_FIELD_ID }}
          EXPIRES_FIELD_ID: ${{ vars.EXPIRES_FIELD_ID }}
        with:
          env_name: ${{ inputs.env_name }}
          ttl_hours: ${{ inputs.ttl_hours }}
          purpose: ${{ inputs.purpose }}
