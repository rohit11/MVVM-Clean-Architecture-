name: Lock Environment (Project Board)

on:
  workflow_dispatch:
    inputs:
      env_name:
        description: "Environment row title in the Project (e.g., env1, env12)"
        required: true
        type: string
      branch_name:
        description: "Branch name to record on the Project item"
        required: true
        type: string
      component_name:
        description: "Component name to deploy"
        required: true
        type: string
      component_version:
        description: "Component version to deploy"
        required: true
        type: string
      neptune_tenant:
        description: "Neptune tenant to run on"
        required: true
        type: string
      aws_region:
        description: "AWS region to deploy to"
        required: true
        type: string
      ttl_hours:
        description: "How many hours to lock this env (used only when acquiring a NEW lock, or when extending explicitly)"
        required: true
        default: "8"
        type: string
      purpose:
        description: "Why you need this env (ticket/PR/testing)"
        required: true
        type: string

permissions:
  contents: read

jobs:
  lock:
    runs-on: ubuntu-latest
    steps:
      - name: Lock env row in Project (no auto-extend; Blocked-safe)
        id: lock_env
        uses: actions/github-script@v7
        env:
          # ---- Repo Variables (Settings -> Secrets and variables -> Actions -> Variables) ----
          PROJECT_ID: ${{ vars.PROJECT_ID }}

          STATUS_FIELD_ID: ${{ vars.STATUS_FIELD_ID }}
          STATUS_AVAILABLE_OPTION_ID: ${{ vars.STATUS_AVAILABLE_OPTION_ID }}
          STATUS_INUSE_OPTION_ID: ${{ vars.STATUS_INUSE_OPTION_ID }}
          STATUS_BLOCKED_OPTION_ID: ${{ vars.STATUS_BLOCKED_OPTION_ID }}

          OWNER_FIELD_ID: ${{ vars.OWNER_FIELD_ID }}
          PURPOSE_FIELD_ID: ${{ vars.PURPOSE_FIELD_ID }}
          BRANCH_FIELD_ID: ${{ vars.BRANCH_FIELD_ID }}
          UPDATED_AT_UTC_FIELD_ID: ${{ vars.UPDATED_AT_UTC_FIELD_ID }}
          COMPONENT_NAME_FIELD_ID: ${{ vars.COMPONENT_NAME_FIELD_ID }}
          COMPONENT_VERSION_FIELD_ID: ${{ vars.COMPONENT_VERSION_FIELD_ID }}
          NEPTUNE_TENANT_FIELD_ID: ${{ vars.NEPTUNE_TENANT_FIELD_ID }}
          AWS_REGION_FIELD_ID: ${{ vars.AWS_REGION_FIELD_ID }}

          EXPIRES_UTC_FIELD_ID: ${{ vars.EXPIRES_UTC_FIELD_ID }}  # Text field (date + time)
        with:
          github-token: ${{ secrets.PROJECTS_TOKEN }}
          script: |
            /**
             * BUSINESS LOGIC (Lock)
             * ---------------------
             * Goal: Acquire an env lock safely without letting repeated runs extend the lock forever.
             *
             * Rule set:
             * 1) Always read current state first (Status/Owner/Expiry).
             * 2) If Status == BLOCKED => FAIL (never lock).
             * 3) If Status == IN USE AND not expired:
             *      - If same owner => SUCCESS (do NOT change expiry). Optional: update Purpose only.
             *      - If different owner => FAIL (do not overwrite).
             * 4) If Status == AVAILABLE OR expired => acquire a NEW lock:
             *      - Status = IN USE
             *      - Owner = context.actor (who ran workflow)
             *      - Purpose = input
             *      - Expires UTC (Text) = ISO timestamp (date + time)
             */

            async function main() {
              // ---- Inputs ----
              const dispatchInputs = context.payload.inputs || {};
              const envName = String(dispatchInputs.env_name || "").trim();
              const branchName = String(dispatchInputs.branch_name || "").trim();
              const componentName = String(dispatchInputs.component_name || "").trim();
              const componentVersion = String(dispatchInputs.component_version || "").trim();
              const neptuneTenant = String(dispatchInputs.neptune_tenant || "").trim();
              const awsRegion = String(dispatchInputs.aws_region || "").trim();
              const purpose = String(dispatchInputs.purpose || "").trim();
              const ttlHoursRaw = String(dispatchInputs.ttl_hours || "").trim();
              const ttlHours = Number(ttlHoursRaw);

              if (!envName) {
                throw new Error("Invalid env_name: value is required.");
              }
              if (!purpose) {
                throw new Error("Invalid purpose: value is required.");
              }
              if (!branchName) {
                throw new Error("Invalid branch_name: value is required.");
              }
              if (!componentName) {
                throw new Error("Invalid component_name: value is required.");
              }
              if (!componentVersion) {
                throw new Error("Invalid component_version: value is required.");
              }
              if (!neptuneTenant) {
                throw new Error("Invalid neptune_tenant: value is required.");
              }
              if (!awsRegion) {
                throw new Error("Invalid aws_region: value is required.");
              }
              if (!Number.isFinite(ttlHours) || ttlHours <= 0) {
                throw new Error(`Invalid ttl_hours="${ttlHoursRaw}". Must be a positive number.`);
              }

              // ---- Config/IDs ----
              const projectId = process.env.PROJECT_ID;
              const statusFieldId = process.env.STATUS_FIELD_ID;

              const optAvailable = process.env.STATUS_AVAILABLE_OPTION_ID;
              const optInUse = process.env.STATUS_INUSE_OPTION_ID;
              const optBlocked = (process.env.STATUS_BLOCKED_OPTION_ID || "").trim();

              const ownerFieldId = process.env.OWNER_FIELD_ID;
              const purposeFieldId = process.env.PURPOSE_FIELD_ID;
              const branchFieldId = process.env.BRANCH_FIELD_ID;
              const updatedAtFieldId = process.env.UPDATED_AT_UTC_FIELD_ID;
              const componentNameFieldId = process.env.COMPONENT_NAME_FIELD_ID;
              const componentVersionFieldId = process.env.COMPONENT_VERSION_FIELD_ID;
              const neptuneTenantFieldId = process.env.NEPTUNE_TENANT_FIELD_ID;
              const awsRegionFieldId = process.env.AWS_REGION_FIELD_ID;

              const expiresUtcFieldId = (process.env.EXPIRES_UTC_FIELD_ID || "").trim();

              const required = {
                PROJECT_ID: projectId,
                STATUS_FIELD_ID: statusFieldId,
                STATUS_AVAILABLE_OPTION_ID: optAvailable,
                STATUS_INUSE_OPTION_ID: optInUse,
                OWNER_FIELD_ID: ownerFieldId,
                PURPOSE_FIELD_ID: purposeFieldId,
                BRANCH_FIELD_ID: branchFieldId,
                UPDATED_AT_UTC_FIELD_ID: updatedAtFieldId,
                COMPONENT_NAME_FIELD_ID: componentNameFieldId,
                COMPONENT_VERSION_FIELD_ID: componentVersionFieldId,
                NEPTUNE_TENANT_FIELD_ID: neptuneTenantFieldId,
                AWS_REGION_FIELD_ID: awsRegionFieldId
              };
              for (const [k, v] of Object.entries(required)) {
                if (!v) throw new Error(`Missing repo variable: ${k}`);
              }

              const actor = context.actor;
              const now = new Date();
              const updatedAtIso = now.toISOString();

              // ---- Export inputs for downstream steps ----
              core.exportVariable("COMPONENT_NAME", componentName);
              core.exportVariable("COMPONENT_VERSION", componentVersion);
              core.exportVariable("NEPTUNE_TENANT", neptuneTenant);
              core.exportVariable("AWS_REGION", awsRegion);
              core.exportVariable("BRANCH_NAME", branchName);
              core.exportVariable("PURPOSE", purpose);
              core.exportVariable("ENV_NAME", envName);

              core.setOutput("component_name", componentName);
              core.setOutput("component_version", componentVersion);
              core.setOutput("neptune_tenant", neptuneTenant);
              core.setOutput("aws_region", awsRegion);
              core.setOutput("branch_name", branchName);
              core.setOutput("purpose", purpose);
              core.setOutput("env_name", envName);

              // ---- Compute NEW expiry (used only when acquiring a new lock) ----
              const newExpiresAtIso = new Date(now.getTime() + ttlHours * 60 * 60 * 1000).toISOString();

              // ---- Fetch project items and field values ----
              let item = null;
              let cursor = null;
              let page = 0;
              const maxPages = 20; // safety cap: 100 * 20 = 2000 items

              const norm = (s) => (s || "").trim().toLowerCase();
              const targetName = norm(envName);
              const getItemTitle = (i) => {
                const contentTitle = i?.content?.title;
                if (contentTitle) return contentTitle;
                const titleField = (i?.fieldValues?.nodes || []).find(
                  n => n.__typename === "ProjectV2ItemFieldTextValue" &&
                    norm(n.field?.name) === "title"
                );
                return titleField?.text || "";
              };

              while (!item) {
                page += 1;
                if (page > maxPages) {
                  throw new Error(`Env row "${envName}" not found after ${maxPages} pages. Increase maxPages or reduce project size.`);
                }

                const proj = await github.graphql(`
                  query($projectId: ID!, $after: String) {
                    node(id: $projectId) {
                      ... on ProjectV2 {
                        items(first: 100, after: $after) {
                          pageInfo { hasNextPage endCursor }
                          nodes {
                            id
                            content {
                              __typename
                              ... on DraftIssue { title }
                              ... on Issue { title }
                              ... on PullRequest { title }
                            }
                            fieldValues(first: 50) {
                              nodes {
                                __typename
                                ... on ProjectV2ItemFieldTextValue {
                                  text
                                  field { ... on ProjectV2FieldCommon { id name } }
                                }
                                ... on ProjectV2ItemFieldSingleSelectValue {
                                  name
                                  optionId
                                  field { ... on ProjectV2FieldCommon { id name } }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                `, { projectId, after: cursor });

                const items = proj?.node?.items?.nodes ?? [];
                item = items.find(i => norm(getItemTitle(i)) === targetName);

                const pageInfo = proj?.node?.items?.pageInfo;
                if (!pageInfo?.hasNextPage) {
                  break;
                }
                cursor = pageInfo.endCursor;
              }

              if (!item) {
                throw new Error(`Env row "${envName}" not found in Project.`);
              }

              const itemId = item.id;

              // ---- Read helpers ----
              function getSingleSelect(fieldId) {
                const v = item.fieldValues.nodes.find(
                  n => n.__typename === "ProjectV2ItemFieldSingleSelectValue" && n.field?.id === fieldId
                );
                return v ? { name: v.name, optionId: v.optionId } : null;
              }
              function getText(fieldId) {
                const v = item.fieldValues.nodes.find(
                  n => n.__typename === "ProjectV2ItemFieldTextValue" && n.field?.id === fieldId
                );
                return v ? v.text : "";
              }
              const curStatus = getSingleSelect(statusFieldId);
              const curOwner = getText(ownerFieldId);
              const curExpiresUtc = expiresUtcFieldId ? getText(expiresUtcFieldId) : "";

              // ---- Determine expiry ----
              let curExpiryMs = 0;
              if (curExpiresUtc) {
                const parsed = Date.parse(curExpiresUtc);
                curExpiryMs = Number.isFinite(parsed) ? parsed : 0;
              }

              const isExpired = curExpiryMs > 0 && curExpiryMs <= now.getTime();
              const curStatusName = (curStatus?.name || "").trim().toLowerCase();

              const isInUse =
                (curStatus?.optionId === optInUse) ||
                (curStatusName === "in use");

              const isBlocked =
                (optBlocked && curStatus?.optionId === optBlocked) ||
                (curStatusName === "blocked");

              const isAvailable =
                (curStatus?.optionId === optAvailable) ||
                (curStatusName === "available") ||
                (!curStatus); // treat empty status as available-ish

              core.notice(`Matched "${envName}" itemId=${itemId}`);
              core.notice(`Current status="${curStatus?.name || "n/a"}" owner="${curOwner}" expiresUtc="${curExpiresUtc}" expired=${isExpired}`);

              // ---- BLOCKED rule ----
              if (isBlocked) {
                throw new Error(`Env "${envName}" is BLOCKED and cannot be locked.`);
              }

              // ---- Helper mutations ----
              async function setSingleSelect(fieldId, optionId) {
                await github.graphql(`
                  mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                    updateProjectV2ItemFieldValue(
                      input: {
                        projectId: $projectId,
                        itemId: $itemId,
                        fieldId: $fieldId,
                        value: { singleSelectOptionId: $optionId }
                      }
                    ) { projectV2Item { id } }
                  }
                `, { projectId, itemId, fieldId, optionId });
              }
              async function setText(fieldId, text) {
                await github.graphql(`
                  mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $text: String!) {
                    updateProjectV2ItemFieldValue(
                      input: {
                        projectId: $projectId,
                        itemId: $itemId,
                        fieldId: $fieldId,
                        value: { text: $text }
                      }
                    ) { projectV2Item { id } }
                  }
                `, { projectId, itemId, fieldId, text });
              }
              // ---- IN USE + NOT EXPIRED rule (no auto-extend) ----
              if (isInUse && !isExpired) {
                if (curOwner && curOwner.toLowerCase() === actor.toLowerCase()) {
                  // Same owner: allow "re-lock" but DO NOT change expiry.
                  // Optional: update purpose to latest reason.
                  await setText(purposeFieldId, purpose);
                  await setText(branchFieldId, branchName);
                  await setText(componentNameFieldId, componentName);
                  await setText(componentVersionFieldId, componentVersion);
                  await setText(neptuneTenantFieldId, neptuneTenant);
                  await setText(awsRegionFieldId, awsRegion);
                  await setText(updatedAtFieldId, updatedAtIso);

                  core.setOutput("ok", "true");
                  core.setOutput("action", "noop_same_owner");
                  core.setOutput("message", `Env "${envName}" is already locked by you. Keeping existing expiry (no auto-extend).`);
                  core.notice(`No-op (same owner). Kept existing expiry: ${curExpiresUtc || "unknown"}`);
                  return;
                } else {
                  // Different owner: do not overwrite
                  throw new Error(`Env "${envName}" is already In Use by "${curOwner}". Expires: ${curExpiresUtc || "unknown"}.`);
                }
              }

              // ---- AVAILABLE or EXPIRED => acquire NEW lock ----
              // If it was expired but still marked In Use, we treat that as releasable and then relock.
              if (isAvailable || isExpired || isInUse) {
                await setSingleSelect(statusFieldId, optInUse);
                await setText(ownerFieldId, actor);
                await setText(purposeFieldId, purpose);
                await setText(branchFieldId, branchName);
                await setText(componentNameFieldId, componentName);
                await setText(componentVersionFieldId, componentVersion);
                await setText(neptuneTenantFieldId, neptuneTenant);
                await setText(awsRegionFieldId, awsRegion);

                if (expiresUtcFieldId) {
                  await setText(expiresUtcFieldId, newExpiresAtIso);
                }
                await setText(updatedAtFieldId, updatedAtIso);

                core.setOutput("ok", "true");
                core.setOutput("action", "locked");
                core.setOutput("message", `Locked "${envName}" by ${actor} for ${ttlHours}h.`);
                core.notice(`Locked "${envName}" by ${actor} for ${ttlHours}h. ExpiresUTC=${newExpiresAtIso}`);
                return;
              }

              // Fallback (should not hit)
              throw new Error(`Unexpected state for "${envName}". Status="${curStatus?.name || "n/a"}".`);
            }

            // Capture failures as outputs so email step can include reason
            try {
              await main();
            } catch (err) {
              const msg = (err && err.message) ? err.message : String(err);
              core.setOutput("ok", "false");
              core.setOutput("action", "failed");
              core.setOutput("message", msg);
              core.warning(`Lock failed: ${msg}`);
            }

      - name: Fail job (after emailing)
        if: steps.lock_env.outputs.ok == 'false'
        run: |
          echo "Lock failed: ${{ steps.lock_env.outputs.message }}"
          exit 1
